import java.io.*;
import java.util.*;

// Symbol Table entry class
class Symbol {
    String name;
    int address;
}

// Literal Table entry class
class Literal {
    String value;
    int address;
}

public class Pass1_Assembler {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);

        Symbol[] symtab = new Symbol[30];
        Literal[] littab = new Literal[30];
        int[] pooltab = new int[10];

        String[] intermediate = new String[50];
        String[] source = new String[50];

        int symCount = 0, litCount = 0, poolCount = 0, interCount = 0;
        int LC = 0;

        // ---------- READ INPUT FROM FILE ----------
        System.out.print("Enter input filename (e.g. input.txt): ");
        String filename = sc.nextLine();

        BufferedReader br = new BufferedReader(new FileReader(filename));
        String line;
        int lineCount = 0;

        while ((line = br.readLine()) != null) {
            if (line.equalsIgnoreCase("END")) break;
            source[lineCount++] = line;
        }
        br.close();

        pooltab[poolCount++] = 0; // first pool starts from index 0

        // ---------- PASS 1 ----------
        for (int i = 0; i < lineCount; i++) {
            line = source[i].trim();
            if (line.isEmpty()) continue;

            String label = "", opcode = "", operand = "";
            String[] parts = line.split("\\s+",3);

            if (parts.length == 1) opcode = parts[0];
            else if (parts.length == 2) {
                opcode = parts[0];
                operand = parts[1];
            } else if (parts.length == 3) {
                label = parts[0];
                opcode = parts[1];
                operand = parts[2];
            }

            // START directive
            if (opcode.equalsIgnoreCase("START")) {
                LC = Integer.parseInt(operand);
                intermediate[interCount++] = "(AD,01) (C," + operand + ")";
            }

            // Declarative statements (DC, DS)
            else if (opcode.equalsIgnoreCase("DC") || opcode.equalsIgnoreCase("DS")) {
                Symbol s = new Symbol();
                s.name = label;
                s.address = LC;
                symtab[symCount++] = s;

                if (opcode.equalsIgnoreCase("DC")) {
                    intermediate[interCount++] = "(DL,01) (C," + operand + ")";
                    LC++;
                } else {
                    intermediate[interCount++] = "(DL,02) (C," + operand + ")";
                    LC += Integer.parseInt(operand);
                }
            }

            // Imperative statements
            else if (opcode.equalsIgnoreCase("MOVER") || opcode.equalsIgnoreCase("MOVEM")
                    || opcode.equalsIgnoreCase("ADD") || opcode.equalsIgnoreCase("SUB")) {

                // Check for literal operand like =’5’
                if (operand.startsWith("=")) {
                    Literal l = new Literal();
                    l.value = operand;
                    l.address = -1;
                    littab[litCount++] = l;
                    intermediate[interCount++] = "(IS," + opcode + ") (L," + (litCount - 1) + ")";
                } else {
                    int index = searchSymbol(symtab, symCount, operand);
                    if (index == -1) {
                        Symbol s = new Symbol();
                        s.name = operand;
                        s.address = -1;
                        symtab[symCount] = s;
			index = symCount;		// remember the position of this symbol
                        symCount++;			// increase the total number of symbols
                    }
                    intermediate[interCount++] = "(IS," + opcode + ") (S," + index + ")";
                }
                LC++;
            }

            // LTORG directive
            else if (opcode.equalsIgnoreCase("LTORG")) {
                intermediate[interCount++] = "(AD,05)";
                for (int j = pooltab[poolCount - 1]; j < litCount; j++) {
                    littab[j].address = LC;
                    LC++;
                }
                pooltab[poolCount++] = litCount;
            }
        }

        // Assign addresses to remaining literals at END
        for (int j = pooltab[poolCount - 1]; j < litCount; j++) {
            littab[j].address = LC;
            LC++;
        }

        // ---------- WRITE OUTPUT FILES ----------
        PrintWriter symFile = new PrintWriter("SYMTAB.txt");
        for (int i = 0; i < symCount; i++)
            symFile.println(symtab[i].name + " " + symtab[i].address);
        symFile.close();

        PrintWriter litFile = new PrintWriter("LITTAB.txt");
        for (int i = 0; i < litCount; i++)
            litFile.println(littab[i].value + " " + littab[i].address);
        litFile.close();

        PrintWriter poolFile = new PrintWriter("POOLTAB.txt");
        for (int i = 0; i < poolCount; i++)
            poolFile.println(pooltab[i]);
        poolFile.close();

        PrintWriter interFile = new PrintWriter("INTERMEDIATE.txt");
        for (int i = 0; i < interCount; i++)
            interFile.println(intermediate[i]);
        interFile.close();

        System.out.println("\nPASS–I Completed ✅");
        System.out.println("Symbol Table written to SYMTAB.txt");
        System.out.println("Literal Table written to LITTAB.txt");
        System.out.println("Pool Table written to POOLTAB.txt");
        System.out.println("Intermediate Code written to INTERMEDIATE.txt");
    }

    static int searchSymbol(Symbol[] symtab, int count, String name) {
        for (int i = 0; i < count; i++) {
            if (symtab[i].name.equals(name))
                return i;
        }
        return -1;
    }
}
